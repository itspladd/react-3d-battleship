{"version":3,"sources":["hooks/useGameEngine.js","classes/Tile.js","classes/Entity.js","classes/Board.js","classes/Player.js","classes/Game.js","classes/Ship.js","classes/BattleshipControls.js","classes/GameViewer.js","hooks/use3DBoard.js","components/GameWindow.jsx","constants/socket.js","components/App.jsx","reportWebVitals.js","index.js","constants/3DBOARD.js"],"names":["require","GameEngine","CONSTANTS","TILE_RADIUS","TILE_GEOMETRY","TILE_THICKNESS","TILE_HEIGHT","Tile","TILE_BASE","type","this","_timestamp","Date","now","boardColor","THREE","COLORS","PLAYER_BOARD_TILE_BASE_COLOR","boardHoverColor","PLAYER_BOARD_TILE_HOVER_COLOR","fillerColor","TILE_NONINTERACTIVE_COLOR","material","MATERIALS","TILE_MATERIAL","geometry","rotateX","Math","PI","rotateZ","InstancedTile","id","mesh","position","color","_id","_mesh","_color","_x","_y","position3D","setColorAt","matrix","getMatrixAt","setFromMatrixPosition","vector3","x","y","z","setMatrixAt","Game","getXYZMatrix","HoverableTile","hoverColor","_hoverColor","raycaster","intersectObject","instanceId","instanceColor","needsUpdate","getHexString","Tiles","PlayerBoardTile","owner","_owner","_engine","engine","tiles","boardX","boardY","_type","playerId","hoverableData","player","newType","startX","startY","Entity","newMesh","zQuat","angle","round","quaternion","angleTo","_w","deg","rad","zAxis","setRotationFromAxisAngle","meshX","xPerTile","boardPosition","boardZ","offset","oddColumnOffset","meshY","yPerTile","meshZ","defaultZ","hoverZ","SHIP_NULL_START","BOARD_DIMENSIONS","Board","boardData","boundaries","board","endX","endY","_start","_end","_rows","rows","_columns","columns","tileMesh","numTiles","frustumCulled","makeTiles","tilesById","tilesByPosition","ships","makeShips","placedShips","updateShip","bind","Object","values","map","ship","tileId","tileMatrix","row","tileMatrixRow","tile","tileType","typeStack","length","push","shipsData","nullCounter","shipId","nullPosition","shipData","Ship","placeAtNull","relX","relY","zOffset","hover","Player","playerData","boardBoundary","name","rules","players","_name","_rules","HELPERS","positionHelpers","getNeighborsInDirection","ROWS_TOP","ROWS_BOTTOM","COLUMNS_LEFT","COLUMNS_RIGHT","COLUMNS_BETWEEN","gameStateRef","ownerID","findPlayerBoundaries","gameState","firstBoardPlayerId","playersArr","shift","playerBoundaries","currentX","i","currentPlayer","_ownerID","_gameStateRef","mapDimensions","currentState","boardBoundaries","initPlayers","fillerTiles","initFillerTiles","mapRows","mapColumns","shipMeshes","current","playerShips","owningPlayer","shipsArr","boards","currentBoardBoundaries","filter","boundary","fillerTileMesh","totalTiles","tileCounter","locationInBoardBoundaries","locationInArea","startPos","endPos","playerRows","playerCols","reduce","a","b","spacerColsNeeded","forEach","engineBoard","engineShips","viewerBoard","threeObj","translation","rotation","moveObjectBy","rotateObjDeg","applyMatrix","getXYCoordinates","newX","newY","makeTranslation","baseRotationMatrix","makeRotationX","typeStr","segments","makeSegments","segmentArr","segmentGroup","_segmentArr","_segmentGroup","_angle","_nullPosition","_selected","_hovered","_placed","children","nullX","nullY","atNull","newVal","placed","segment","intersectObjects","segmentMeshes","target","index","makeSegmentMesh","add","segmentLength","segmentGeom","nullZOffset","MOVES","RULES","DEFAULT_RULES","BattleshipControls","camera","domElement","setViewerData","setMoveData","_raycaster","_currentHovers","_prevHovers","_currentSelected","_prevSelected","_placementTargets","mainHover","enableHovering","enableSelection","_pointer","setupPointer","maxPolarAngle","minPolarAngle","onPointerMove","onPointerDown","onPointerUp","onWheel","handleNewHover","handleAbandonedHover","addEventListener","object","_game","gameObj","engineObj","game","playerID","gamePlayer","enginePlayer","selection","_pointerDownTime","pointerDown","pointerDelta","obj","hoverable","prevMainHover","hovers","placementTarget","constructor","onDeselect","pop","enableZoom","_potentialSelect","sendUnplaceShipMove","onSelect","setFromCamera","detectHovers","handleHovers","updateData","event","clientX","window","innerWidth","clientY","innerHeight","pointer","normalizedPosition","rawPosition","cam","prev","preventDefault","selectables","includes","enablePan","setTimeout","dragging","canPlace","console","log","place","deselect","select","myBoardHovers","sendMoveShipMove","angleDelta","deltaY","enginePosition","selectable","canMoveTo","validShipLocation","hoverables","h","currentHover","engineShip","gameBoard","hovering","prevHovering","newHovers","currentHoverable","abandonedHovers","prevHoverable","newMainHover","unshift","hoverData","selected","onHover","onHoverExit","onPlace","sendPlaceShipMove","shipID","moveType","MOVE_SHIP","NAME","targetPlayerID","PLACE_SHIP","UNPLACE_SHIP","MapControls","GameViewer","canvasRef","messageDataRef","_canvasRef","_setViewerData","_messageDataRef","_scene","_renderer","canvas","_camera","setupCamera","_controls","setupControls","setSize","_lights","setupLights","_axes","makeAxes","addArr","animate","update","flag","_currentGame","objects","up","lookAt","controls","initGame","addGameToScene","light","ambientLight","timestamp","requestAnimationFrame","handleAnimationLoop","render","toFixed","box","m","cube","GameWindow","renderCanvas","useRef","newEngine","useState","moves","setMoves","useEffect","makeMove","move","inputMove","results","useGameEngine","worldPosition","currentSelect","objectId","selectStack","viewerData","moveData","viewer","use3DBoard","status","setStatus","details","setDetails","moveAndUpdate","then","msg","valid","catch","err","shipList","makeDetails","recursive","list","key","Array","isArray","makeString","arr","pos","Number","parseFloat","join","mouseData","cameraPos","cameraRot","mouseDataText","cameraPosText","cameraRotText","currentHoverInfo","JSON","stringify","className","onClick","p1Move","handleClick","disabled","ref","SOCKET_DATA","App","socketConnected","state","setState","socket","socketClient","on","disconnect","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById","sin","TILE_SIDE","roughness","metalness","BAD_HOVER_COLOR","LIGHT_BASE_COLOR","module","exports"],"mappings":"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","file":"static/js/main.71771889.chunk.js","sourcesContent":["import { useEffect, useRef, useState } from 'react'\n\n// Engine\nconst { GameEngine, CONSTANTS } = require('@itspladd/battleship-engine')\n\nexport default function useGameEngine() {\n  // Dummy players object to hold dev data.\n  const players = [\n    { id: 'p1', name: 'Trapezius' },\n    { id: 'p2', name: 'Tautrion' }\n  ];\n  const newEngine = new GameEngine({players})\n  newEngine.timestamp = Date.now();\n  const [engine, setEngine] = useState(newEngine);\n  const [moves, setMoves] = useState({});\n  const gameStateRef = useRef(engine.gameState);\n\n  useEffect(() => {\n    setMoves(CONSTANTS.RULES.DEFAULT_RULES.MOVES)\n  }, [])\n\n\n  const makeMove = async (move) => {\n    console.log('making a move: ', move)\n    const results = await engine.inputMove(move);\n    gameStateRef.current = results.gameState\n    return results;\n  }\n\n  return [engine, moves, gameStateRef, makeMove]\n}","import * as THREE from 'three';\nimport { TILE_GEOMETRY, MATERIALS, COLORS } from '../constants/3DBOARD';\n\nimport Game from './Game';\n\nconst { TILE_RADIUS, TILE_HEIGHT, TILE_THICKNESS, TILE_BASE } = TILE_GEOMETRY;\n\nclass Tile {\n  static boardColor = new THREE.Color(COLORS.PLAYER_BOARD_TILE_BASE_COLOR);\n  static boardHoverColor = new THREE.Color(COLORS.PLAYER_BOARD_TILE_HOVER_COLOR);\n  static fillerColor = new THREE.Color(COLORS.TILE_NONINTERACTIVE_COLOR)\n  static material = new THREE.MeshStandardMaterial({...MATERIALS.TILE_MATERIAL});\n  static geometry = new THREE.CylinderBufferGeometry(TILE_RADIUS * .95, TILE_RADIUS, TILE_THICKNESS, 6)\n                    .rotateX(Math.PI * 0.5)  // Turn the tile so it's laying \"flat\"\n                    .rotateZ(Math.PI * 0.5); // Turn the tile to \"point\" sideways\n\n  constructor(type) {\n    this._timestamp = Date.now();\n  }\n}\n\nclass InstancedTile extends Tile {\n\n  constructor(id, mesh, position, color = Tile.fillerColor) {\n    super();\n    this._id = id;\n    this._mesh = mesh;\n    this._color = color; // Save the color of the tile\n    this.color = color; // Actually set the color of the tile\n    this._x = position[0];\n    this._y = position[1];\n    this.position3D = position;\n\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  get color() {\n    return this._color;\n  }\n\n  set color(color) {\n    this._mesh.setColorAt(this._id, color)\n  }\n\n  // Position in 3D space using float values.\n  set position3D(vector3) {\n    const [x, y, z] = vector3;\n    this._mesh.setMatrixAt(this._id, Game.getXYZMatrix(x, y, z))\n  }\n\n  get position3D() {\n    const matrix = this._mesh.getMatrixAt(this._id)\n    const position = new THREE.Vector3();\n    position.setFromMatrixPosition(matrix);\n    return position;\n  }\n\n  // Position in global tile set using integer values.\n  get position() {\n    return [this._x, this._y];\n  }\n}\n\nclass HoverableTile extends InstancedTile {\n  constructor(id, mesh, position, color, hoverColor) {\n    super(id, mesh, position, color);\n    this._hoverColor = hoverColor;\n  }\n\n  currentlyHovered(raycaster) {\n    return raycaster.intersectObject(this._mesh)[0].instanceId === this.id;\n  }\n\n  onHover() {\n    this.color = this._hoverColor;\n    this._mesh.instanceColor.needsUpdate = true;\n  }\n\n  duringHover() {\n\n  }\n\n  onHoverExit() {\n    this.color = this._color;\n    this._mesh.instanceColor.needsUpdate = true;\n  }\n\n  get hoverData() {\n    return {\n      id: this.id,\n      position: this.position,\n      color: this.color.getHexString(),\n      hoverColor: this._hoverColor.getHexString()\n    }\n  }\n\n  get hoverable() {\n    return true;\n  }\n}\n\nclass PlayerBoardTile extends HoverableTile {\n  constructor(id, mesh, position, owner, type) {\n    super(id, mesh, position, Tile.boardColor, Tile.boardHoverColor);\n    this._owner = owner;\n    this._engine = this.owner.engine.tiles[this.boardX][this.boardY]\n    this._type = type;\n  }\n\n  get owner() {\n    return this._owner;\n  }\n\n  get engine() {\n    return this._engine;\n  }\n\n  get playerId() {\n    return this._owner.playerId;\n  }\n\n  get hoverData() {\n    const hoverableData = super.hoverData;\n    return {\n      ...hoverableData,\n      player: this.playerId\n    }\n  }\n\n  set type(newType) {\n    this._type = newType;\n  }\n\n  get boardX() {\n    return this._x - this.owner.startX;\n  }\n\n  get boardY() {\n    return this._y - this.owner.startY\n  }\n\n  // Position on this specific game board using integer values.\n  get boardPosition() {\n    return [this.boardX, this.boardY]\n  }\n}\n\nconst Tiles = {\n  Tile,\n  InstancedTile,\n  HoverableTile,\n  PlayerBoardTile\n};\n\nexport default Tiles;","import * as THREE from 'three'\nconst { TILE_RADIUS, TILE_HEIGHT } = require('../constants/3DBOARD').TILE_GEOMETRY\n\n// An Entity is an object in the game world with a position and a rotation.\nclass Entity {\n\n  // Horizontal distance from center of one tile to center of next\n  static xPerTile = 1.5 * TILE_RADIUS;\n  // Vertical distance from center of one tile to center of next\n  static yPerTile = 2 * TILE_HEIGHT;\n  // Extra vertical offset for odd-numbered columns\n  static oddColumnOffset = Entity.yPerTile / 2;\n\n  static defaultZ = 0;\n  static hoverZ = 2.5;\n\n  constructor(mesh) {\n    this._mesh = mesh || null;\n  }\n\n  get mesh() {\n    return this._mesh;\n  }\n\n  get meshPosition() {\n    return this._mesh.position;\n  }\n\n  get meshX() {\n    return this._mesh.position.x;\n  }\n\n  get meshY() {\n    return this._mesh.position.y;\n  }\n\n  get meshZ() {\n    return this._mesh.position.z;\n  }\n\n  get angle() {\n    // In degrees because I'm nasty. sorry\n    const zQuat = new THREE.Quaternion(0, 0, 0, 1)\n    const angle = Math.round((this._mesh.quaternion.angleTo(zQuat) * 360) / (2 * Math.PI))\n\n    // Weird behavior when angle is at 360 or 0, so hard return 0.\n    if(angle === 360 || angle === 0) {\n      return 0;\n    }\n\n    // The w component is negative for 60 and 120 deg, positive for 240 and 300 deg\n    // \"angle\" will be the same for 120/240 and 60/300 deg respectively\n    // So depending on the w component being pos/neg, we manually calculate what angle we're at\n    // Sorry if this explanation sucks. I can try drawing it if you ask me.\n    const w = this.mesh.quaternion._w;\n    const result = w > 0 ? -1 * (angle - 360) : angle\n    return result\n  }\n\n  get boardX() {\n    return Math.round(this.meshX / Entity.xPerTile)\n  }\n\n  get boardY() {\n    const offset = (this.boardX % 2) * Entity.oddColumnOffset\n    const y = -1 * Math.round((this.meshY + offset) / Entity.yPerTile)\n    return y\n  }\n\n  get boardZ() {\n    return this.meshZ;\n  }\n\n  get boardPosition() {\n    return [this.boardX, this.boardY];\n  }\n\n  set mesh(newMesh) {\n    this._mesh = newMesh;\n  }\n\n  // Given an integer X and Y and optional Z\n  set boardPosition(vector3) {\n    //console.log('setting board position at', vector3)\n    const [x, y, z] = vector3;\n\n    // meshX is just number of tiles times x per tile\n    const meshX = x * Entity.xPerTile;\n\n    // If the column is odd (x%2 = 1), add the extra offset to y value\n    // (because of how hex grids work)\n    // It's also negative bc we move downward from the origin\n    const meshY = -1 * (y * Entity.yPerTile + ((x % 2) * Entity.oddColumnOffset));\n\n    // If z is non-zero falsy (i.e. not provided), set it to default;\n    // otherwise save it.\n    const meshZ = (!z && z !== 0) ? Entity.defaultZ : z;\n\n    // Actually set the locations.\n    this.mesh.position.x = meshX;\n    this.mesh.position.y = meshY;\n    this.mesh.position.z = meshZ;\n  }\n\n  set angle(deg) {\n    // Rotation begins in the opposite direction you expect, so we flip the amount.\n    deg = -1 * (deg - 360)\n    const rad = (deg / 360) * 2 * Math.PI\n    const zAxis = new THREE.Vector3(0, 0, 1);\n    this.mesh.setRotationFromAxisAngle(zAxis, rad)\n  }\n\n  set boardX(x) {\n    this.boardPosition = [x, this.boardY, this.boardZ]\n  }\n\n  set boardY(y) {\n    this.boardPosition = [this.boardX, y, this.boardZ]\n  }\n\n  set boardZ(z) {\n    this.boardPosition = [this.boardX, this.boardY, z]\n  }\n}\n\nexport default Entity;","import * as THREE from 'three';\n\nimport Game from './Game'\nimport Ship from './Ship';\nimport Tiles from './Tile'\nimport Entity from './Entity'\n\nconst { Tile, PlayerBoardTile } = Tiles;\n\nconst { SHIP_NULL_START } = require('../constants/3DBOARD').BOARD_DIMENSIONS\n\nclass Board {\n  constructor(owner, boardData, boundaries) {\n    this._owner = owner;\n    this._engine = owner.engine.board;\n    const { startX, startY, endX, endY } = boundaries;\n    this._start = [startX, startY];\n    this._end = [endX, endY];\n    this._rows = boardData.rows;\n    this._columns = boardData.columns;\n    this.tileMesh = new THREE.InstancedMesh(Tile.geometry, Tile.material, this.numTiles)\n    this.tileMesh.frustumCulled = false;\n    const [tilesById, tilesByPosition] = this.makeTiles(boardData);\n    this.tilesById = tilesById;\n    this.tilesByPosition = tilesByPosition;\n    this.ships = this.makeShips(boardData);\n    this.placedShips = {};\n    this.updateShip = this.updateShip.bind(this);\n  }\n\n  get engine() {\n    return this._engine;\n  }\n\n  get tiles() {\n    return this.tilesById;\n  }\n\n  get shipsArr() {\n    return Object.values(this.ships);\n  }\n\n  get startX() {\n    return this._start[0];\n  }\n\n  get startY() {\n    return this._start[1];\n  }\n\n  get endX() {\n    return this._end[0];\n  }\n\n  get endY() {\n    return this._end[1];\n  }\n\n  get dimensions() {\n    return [this._rows, this._columns]\n  }\n\n  get numTiles() {\n    return this._rows * this._columns\n  }\n\n  get playerId() {\n    return this._owner.id;\n  }\n\n  get shipMeshes() {\n    return Object.values(this.ships).map(ship => ship.mesh)\n  }\n\n  makeTiles(boardData) {\n    let tileId = 0;\n    let y = this.startY;\n    const tiles = {}\n    const tileMatrix = [];\n    for(const row of boardData.tiles) {\n      const tileMatrixRow = [];\n      let x = this.startX;\n      for (const tile of row) {\n        const position = [x, y, 0];\n        const tileType = tile.typeStack[tile.typeStack.length - 1];\n        tiles[tileId] = new PlayerBoardTile(tileId, this.tileMesh, position, this, tileType);\n        tileMatrixRow.push(tileId);\n        tileId++;\n        x++;\n      }\n      y++;\n      tileMatrix.push(tileMatrixRow);\n    }\n\n    return [tiles, tileMatrix];\n  }\n\n  makeShips(boardData) {\n    const shipsData = boardData.ships;\n    const ships = {}\n    let nullCounter = 0;\n    const {x, y, angle} = SHIP_NULL_START;\n    for (let shipId in shipsData) {\n      const nullPosition = [(2 * nullCounter + x), y, angle];\n      const owner = this;\n      const shipData = { ...shipsData[shipId], nullPosition, owner }\n      ships[shipId] = new Ship(shipData)\n      nullCounter++;\n    }\n\n    return ships;\n  }\n\n  updateShip(ship) {\n    const { id, position, angle } = ship;\n    if(position === null) {\n      this.ships[id].placeAtNull();\n    } else {\n      const [relX, relY] = position;\n      const x = relX + this.startX;\n      const y = relY + this.startY;\n      const z = this.placedShips[id] ? Ship.zOffset : Entity.hoverZ;\n      this.ships[id].boardPosition = [x, y, z];\n      this.ships[id].angle = angle;\n    }\n\n  }\n\n  currentHover(raycaster) {\n    const hover = raycaster.intersectObject(this.tileMesh)[0];\n    return hover && this.tiles[hover.instanceId];\n  }\n\n  onHover() {\n    //console.log(raycaster.intersectObject(this.tileMesh)[0]);\n\n  }\n\n  onHoverExit() {\n    //console.log(raycaster.intersectObject(this.tileMesh)[0]);\n\n  }\n}\n\nexport default Board;","import Board from './Board'\n\nclass Player {\n  constructor(owner, playerData, boardBoundary) {\n    const { id, name, rules, board } = playerData;\n    this._owner = owner;\n    this._id = id;\n    this._engine = this._owner.engine.players[id]\n    this._name = name;\n    this._rules = rules;\n\n    this.board = new Board(this, board, boardBoundary)\n  }\n\n  get engine() {\n    return this._engine;\n  }\n\n  get id() {\n    return this._id;\n  }\n}\n\nexport default Player;","import * as THREE from 'three';\n\n// Classes\nimport Player from './Player'\nimport Tiles from './Tile'\n\nconst { Tile, InstancedTile } = Tiles;\n\n// Helpers\nconst { getNeighborsInDirection } = require('@itspladd/battleship-engine').HELPERS.positionHelpers\n\n// Constants\nconst { TILE_RADIUS, TILE_HEIGHT } = require('../constants/3DBOARD').TILE_GEOMETRY\nconst {\n  ROWS_TOP,\n  ROWS_BOTTOM,\n  COLUMNS_LEFT,\n  COLUMNS_RIGHT,\n  COLUMNS_BETWEEN\n} = require('../constants/3DBOARD').BOARD_DIMENSIONS;\n\n\nclass Game {\n\n  /**************************************************\n  STATIC METHODS\n  **************************************************/\n\n  static baseRotationMatrix = new THREE.Matrix4().makeRotationX(Math.PI)\n\n  static moveObject(threeObj, translation, rotation) {\n    const [x, y, z] = translation;\n    this.moveObjectBy(threeObj, x, y, z)\n    this.rotateObjDeg(threeObj, rotation)\n  }\n\n  static rotateObjDeg(threeObj, deg) {\n    // Rotation begins in the opposite direction you expect, so we flip the amount.\n    deg = -1 * (deg - 360)\n    const rad = (deg / 360) * 2 * Math.PI\n\n    threeObj.rotateZ(rad)\n  }\n\n  static moveObjectBy(threeObj, x, y, z) {\n    const matrix = this.getXYZMatrix(x, y, z);\n    threeObj.applyMatrix(matrix)\n  }\n\n  static getXYZMatrix(x, y, z) {\n    const [newX, newY] = this.getXYCoordinates(x, y);\n    const matrix = new THREE.Matrix4();\n    matrix.makeTranslation(newX, newY, z);\n\n    return matrix;\n  }\n\n  /*****************\n   * get3DCoordinates(x: int, y: int)\n   * Given an integer x and y, calculate the float x and y based on tile size.\n   * Returns [floatX, floatY]\n  */\n  static getXYCoordinates(x, y) {\n    // Horizontal distance from center of one tile to center of next\n    const xPerTile = 1.5 * TILE_RADIUS;\n    // Vertical distance from center of one tile to center of next\n    const yPerTile = 2 * TILE_HEIGHT;\n    // Extra vertical offset for odd-numbered columns;\n    const oddColumnOffset = yPerTile / 2;\n\n    // floatX is just number of tiles * offset per tile\n    const floatX = x * xPerTile;\n    // If the column is odd (x%2 = 1), add the extra offset to the Y\n    // (hex tiles function weird)\n    const floatY = y * yPerTile + ((x % 2) * oddColumnOffset);\n\n    // Make the Y negative!\n    return [floatX, floatY * -1]\n  }\n\n  /**************************************************\n  END OF STATIC METHODS\n  **************************************************/\n\n  constructor(gameStateRef, ownerID, engine) {\n    this._ownerID = ownerID;\n    this._gameStateRef = gameStateRef;\n    this._engine = engine;\n\n    this.mapDimensions = this.mapDimensions(this.currentState);\n    this.boardBoundaries = this.findPlayerBoundaries(this.currentState, ownerID)\n\n    // Players create Boards during construction.\n    // Boards include Tiles and Ships, so look in Board.js for Tile/Ship init.\n    this.players = this.initPlayers(this.currentState, this.boardBoundaries);\n    this.fillerTiles = this.initFillerTiles();\n  }\n\n  get engine() {\n    return this._engine;\n  }\n\n  get mapRows() {\n    return this.mapDimensions[0];\n  }\n\n  get mapColumns() {\n    return this.mapDimensions[1];\n  }\n\n\n  get totalTiles() {\n    return this.mapRows * this.mapColumns;\n  }\n\n  get playerShipMeshes() {\n    return this.players[this._ownerID].board.shipMeshes;\n  }\n\n  get currentState() {\n    return this._gameStateRef.current;\n  }\n\n  get owningPlayer() {\n    return this.players[this._ownerID];\n  }\n\n  get ownerID() {\n    return this._ownerID\n  }\n\n  get playersArr() {\n    return Object.values(this.players);\n  }\n\n  get hoverables() {\n    const playerShips = this.owningPlayer.board.shipsArr;\n    const boards = this.playersArr.map(player => player.board)\n    return [...playerShips, ...boards, ]\n  }\n\n  get selectables() {\n    const playerShips = this.owningPlayer.board.shipsArr;\n    return [...playerShips]\n  }\n\n  initPlayers(gameState, boardBoundaries) {\n    const players = {}\n    for (let id in gameState.players) {\n      const currentBoardBoundaries = boardBoundaries\n        .filter(boundary => boundary.id === id)\n        [0]\n      players[id] = new Player(this, gameState.players[id], currentBoardBoundaries)\n    }\n\n    return players;\n  }\n\n  initFillerTiles() {\n    const fillerTileMesh = new THREE.InstancedMesh(Tile.geometry, Tile.material, this.totalTiles)\n    fillerTileMesh.frustumCulled = false;\n    const fillerTiles = {};\n    let tileCounter = 0;\n\n    for (let x = 0; x < this.mapColumns; x++) {\n      for (let y = 0; y < this.mapRows; y++) {\n        if (!this.locationInBoardBoundaries(x, y)) {\n          const position = [x, y, 0];\n          fillerTiles[tileCounter] = new InstancedTile(tileCounter, fillerTileMesh, position)\n          tileCounter++;\n        }\n      }\n    }\n    return fillerTileMesh;\n  }\n\n  findPlayerBoundaries = (gameState, firstBoardPlayerId) => {\n    // firstBoardPlayerId: the ID of the player whose board should be first.\n    // Assumes that all boards are placed horizontally next to each other.\n    const playersArr = Object.values(gameState.players);\n\n    // \"Rotate\" the array until the first player ID is the same as the input ID\n    while(playersArr[0].id !== firstBoardPlayerId) {\n      playersArr.push(playersArr.shift());\n    }\n    const playerBoundaries = [];\n    let currentX = COLUMNS_LEFT - 1; // Offset by 1 to account for 0-index\n    for (let i = 0; i < playersArr.length; i++) {\n      const currentPlayer = playersArr[i];\n      const id = currentPlayer.id;\n\n      // Move right 1 from where we stopped last. Add spacer columns between boards.\n      const startX = 1 + currentX + COLUMNS_BETWEEN * i;\n      const startY = ROWS_TOP;\n\n      // Since startX and startY are on the first row/column, subtract 1 to account.\n      const endX = startX + currentPlayer.board.columns - 1;\n      const endY = startY + currentPlayer.board.rows - 1;\n      currentX = endX;\n      playerBoundaries[i] = { id, startX, startY, endX, endY }\n    }\n\n    return playerBoundaries;\n  }\n\n  locationInBoardBoundaries(x, y) {\n    const results = Object.values(this.boardBoundaries)\n      .filter(boundary => {\n        const { startX, startY, endX, endY } = boundary;\n        return this.locationInArea(x, y, [startX, startY], [endX, endY])\n      })\n    return results.length !== 0;\n  }\n\n  locationInArea(x, y, startPos, endPos) {\n    return x >= startPos[0] &&\n           x <= endPos[0]   &&\n           y >= startPos[1] &&\n           y <= endPos[1]\n  }\n\n  mapDimensions(gameState) {\n    const playersArr = Object.values(gameState.players);\n    // Boards are drawn horizontally next to each other, so the\n    // number of player rows is just one player's rows.\n    // Columns need to be added from all players.\n    const playerRows = playersArr[0].board.rows;\n    const playerCols = playersArr.map(player => player.board.columns)\n                      .reduce((a, b) => a + b);\n\n    // Need one COLUMNS_BETWEEN between each player board.\n    const spacerColsNeeded = playersArr.length - 1\n    const spacerColsTotal = COLUMNS_BETWEEN * spacerColsNeeded\n\n    const totalRows = playerRows + ROWS_TOP + ROWS_BOTTOM;\n    const totalCols = playerCols + spacerColsTotal + COLUMNS_LEFT + COLUMNS_RIGHT;\n    return [totalRows, totalCols]\n  }\n\n  update() {\n    //Reposition every element on the board\n    Object.values(this.currentState.players).forEach(player => {\n      const playerId = player.id;\n      const engineBoard = player.board;\n      const engineShips = Object.values(engineBoard.ships);\n      const viewerBoard = this.players[playerId].board\n      viewerBoard.placedShips = {...engineBoard.placedShips}\n      const viewerShips = viewerBoard.ships\n      engineShips.forEach(viewerBoard.updateShip)\n    })\n  }\n}\n\nexport default Game;","import * as THREE from 'three'\nimport Game from './Game'\nimport Entity from './Entity'\nimport Tiles from './Tile'\n\nimport { TILE_GEOMETRY, MATERIALS, COLORS } from '../constants/3DBOARD';\n\nconst { PlayerBoardTile } = Tiles;\nconst { TILE_HEIGHT, TILE_BASE } = TILE_GEOMETRY;\n\n\nclass Ship extends Entity {\n\n  static color = new THREE.Color(0x666666);\n  static hoverColor = new THREE.Color(0x888888);\n  static zOffset = 0.5 + TILE_BASE;\n  static nullZOffset = 0;\n\n  static makeSegments(type, segments) {\n    // Create each segment mesh and add it to the array of segments\n    const segmentArr = segments.map((segment, index) => {\n      const mesh = Ship.makeSegmentMesh(type, index);\n      mesh.position.y = index * (2 * TILE_HEIGHT);\n      return {\n        ...segment,\n        mesh\n      }\n    })\n\n    // Create the group that holds all the segments for positioning\n    const segmentGroup = new THREE.Group();\n    segmentArr.forEach(segment => segmentGroup.add(segment.mesh))\n\n    return [segmentArr, segmentGroup]\n  }\n\n  static makeSegmentMesh(type, index) {\n    const segmentLength = TILE_HEIGHT * 2;\n    const segmentGeom = new THREE.BoxGeometry( 1, segmentLength, 1)\n    const material = new THREE.MeshBasicMaterial( {color: Ship.color} );\n\n    return new THREE.Mesh(segmentGeom, material);\n  }\n\n  constructor({typeStr, segments, angle, position, nullPosition, id, owner}) {\n\n    const [segmentArr, segmentGroup] = Ship.makeSegments(typeStr, segments);\n    // Run the Entity constructor to save segmentGroup as this._mesh:\n    super(segmentGroup)\n    this._owner = owner;\n    this._engine = owner.engine.ships[id]\n    this._type = typeStr;\n    this._segmentArr = segmentArr;\n    this._segmentGroup = segmentGroup;\n    this._angle = angle;\n    this._id = id;\n    this._nullPosition = nullPosition;\n    this._selected = false;\n    this._hovered = false;\n    this._placed = false;\n    this.placeAtNull();\n  }\n\n  get owner() {\n    return this._owner;\n  }\n\n  get engine() {\n    return this._engine;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  get segmentMeshes() {\n    return this._segmentGroup.children;\n  }\n\n  get nullX() {\n    return this._nullPosition[0];\n  }\n\n  get nullY() {\n    return this._nullPosition[1];\n  }\n\n  get nullAngle() {\n    return this._nullPosition[2];\n  }\n\n  get atNull() {\n    return this.boardX === this.nullX &&\n           this.boardY === this.nullY;\n  }\n\n  get enginePosition() {\n    return this.atNull ? null : [this.boardX - this.owner.startX, this.boardY - this.owner.startY]\n  }\n\n  get hovered() {\n    return this._hovered;\n  }\n\n  get selected() {\n    return this._selected;\n  }\n\n  get placed() {\n    return this._placed;\n  }\n\n  set placed(newVal) {\n    this._placed = newVal;\n  }\n\n  get hoverData() {\n    return {\n      id: this._id,\n      position: this.boardPosition,\n      angle: this._angle,\n      nullPosition: this._nullPosition,\n      type: this._type,\n      placed: this.placed\n    }\n  }\n\n  set color(color) {\n    this._segmentArr.forEach(segment => {\n      segment.mesh.material.color = color;\n    })\n  }\n\n  placeAtNull() {\n    const [x, y, angle] = this._nullPosition;\n    this.angle = angle;\n    this.boardPosition = [x, y]\n  }\n\n  currentHover(raycaster) {\n    return raycaster.intersectObjects(this.segmentMeshes).length > 0 && this;\n  }\n\n  onHover() {\n    this._hovered = true;\n    this.color = Ship.hoverColor;\n  }\n\n  onHoverExit() {\n    this._hovered = false;\n    this.color = Ship.color;\n  }\n\n  onSelect() {\n    this._selected = true;\n    this._placed = false;\n    this.color = Ship.hoverColor;\n    this.boardZ = Entity.hoverZ;\n  }\n\n  onDeselect() {\n    this._selected = false;\n    this.color = Ship.color;\n  }\n\n  onPlace() {\n    this._placed = true;\n  }\n\n  canMoveTo(target) {\n    return target instanceof PlayerBoardTile &&\n           target.owner.playerId === this.owner.playerId\n  }\n}\n\nexport default Ship;","import * as THREE from 'three';\n\nimport { MapControls } from 'three/examples/jsm/controls/OrbitControls'\nimport Ship from './Ship';\nimport Tiles from './Tile';\n\nconst { Tile, PlayerBoardTile } = Tiles;\nconst { MOVES } = require('@itspladd/battleship-engine').CONSTANTS.RULES.DEFAULT_RULES\n\n\nclass BattleshipControls extends MapControls {\n  constructor( camera, domElement, setViewerData, setMoveData ) {\n    super( camera, domElement );\n    this._raycaster = new THREE.Raycaster();\n    this.setViewerData = setViewerData;\n    this.setMoveData = setMoveData;\n\n    this._currentHovers = [];\n    this._prevHovers = [];\n    this._currentSelected = [];\n    this._prevSelected = [];\n    this._placementTargets = [];\n    this.mainHover = null;\n\n    this.enableHovering = true;\n    this.enableSelection = true;\n\n    this._pointer = this.setupPointer();\n    // Put angle limits on the camera movement\n    //this.maxAzimuthAngle = 0; //Prevent orbiting if uncommented\n    //this.minAzimuthAngle = 0; //Prevent orbiting if uncommented\n    this.maxPolarAngle = (3/16) * Math.PI;\n    this.minPolarAngle = 0;\n\n    this.onPointerMove = this.onPointerMove.bind(this); // Called by window, so scope changes\n    this.onPointerDown = this.onPointerDown.bind(this); // Called by window, so scope changes\n    this.onPointerUp = this.onPointerUp.bind(this); // Called by window, so scope changes\n    this.onWheel = this.onWheel.bind(this); // Called by window, so scope changes\n    this.handleNewHover = this.handleNewHover.bind(this); // Called by a forEach\n    this.handleAbandonedHover = this.handleAbandonedHover.bind(this); // Called by a forEach\n    domElement.addEventListener('mousemove', this.onPointerMove, false);\n    domElement.addEventListener('pointerdown', this.onPointerDown, false);\n    domElement.addEventListener('pointerup', this.onPointerUp, false);\n    domElement.addEventListener('wheel', this.onWheel, false);\n  }\n\n  get camera() {\n    return this.object\n  }\n\n  set game(gameObj) {\n    this._game = gameObj;\n  }\n\n  get game() {\n    return this._game; // _game is the 3D stuff defined in this repo.\n  }\n\n  get engine() {\n    return this._engine; // _engine is the game engine that doesn't know about 3D.\n  }\n\n  set engine(engineObj) {\n    this._engine = engineObj;\n  }\n\n  get gamePlayer() {\n    return this.game.players[this.playerID];\n  }\n\n  get gameBoard() {\n    return this.gamePlayer.board;\n  }\n\n  get enginePlayer() {\n    return this.engine.players[this.playerID];\n  }\n\n  get engineBoard() {\n    return this.enginePlayer.board;\n  }\n\n  get engineShip() {\n    return this.selection ? this.engineBoard.ships[this.selection.id] : null;\n  }\n\n  get playerID() {\n    return this._game.ownerID\n  }\n\n  get pointerDelta() {\n    return Date.now() - this._pointerDownTime;\n  }\n\n  get dragging() {\n    return this.pointerDown && (this.pointerDelta > 500)\n  }\n\n  get selection() {\n    return this._currentSelected[0] || null;\n  }\n\n  set selection(obj) {\n    this._currentSelected.push(obj)\n  }\n\n  get placementTarget() {\n    return this._placementTargets[0] || null;\n  }\n\n  get myBoardHovers() {\n    const hoveredBoardTiles = this._currentHovers.filter(hoverable => hoverable instanceof PlayerBoardTile)\n    const myBoardTiles = hoveredBoardTiles.filter(tile => tile.playerId === this.playerID)\n    return myBoardTiles;\n  }\n\n  get newMainHover() {\n    return this.mainHover && \n           this.prevMainHover &&\n           this.mainHover !== this.prevMainHover\n  }\n\n  get debugData() {\n    return {\n      hovers: this._currentHovers,\n      selection: this.selection,\n      placementTarget: this.placementTarget && this.placementTarget.constructor\n\n    }\n  }\n\n  initGame(game, ownerID, engine) {\n    this.game = game;\n    this.engine = engine;\n  }\n\n  deselect() {\n    this.selection.onDeselect();\n    this._currentSelected.pop();\n\n    //Re-enable zoom.\n    this.enableZoom = true;\n  }\n\n  select() {\n    //Grab new selection and handle it.\n    this.selection = this._potentialSelect;\n    if (this.selection.placed) {\n      this.selection.placed = false;\n      this.sendUnplaceShipMove(this.selection.id)\n    }\n    this.selection.onSelect();\n\n    // Turn off camera zoom so we can rotate the object.\n    this.enableZoom = false;\n\n    // Clear potential selection.\n    this._potentialSelect = null;\n  }\n\n  handleAnimationLoop() {\n    this._raycaster.setFromCamera(this._pointer, this.camera)\n    this.detectHovers() && this.handleHovers() && this.updateData();\n  }\n\n  updateData() {\n    // Only use in case of bugs.\n    //this.setViewerData(prev => ({...prev, controls: this.debugData}));\n  }\n\n  setupPointer() {\n    return new THREE.Vector2(-1, -1);\n  }\n\n  onPointerMove(event) {\n    //calculate mouse position and save it\n    this._pointer.x = (event.clientX / window.innerWidth) * 2 - 1;\n    this._pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    const pointer = {\n      normalizedPosition: [this._pointer.x, this._pointer.y],\n      rawPosition: [event.clientX, event.clientY]\n    }\n    const cam = {\n      position: this.camera.position,\n      rotation: this.camera.quaternion\n    }\n    this.setViewerData(prev => ({\n      ...prev,\n      pointer,\n      camera: cam\n    }))\n  }\n\n  onPointerDown(event) {\n    event.preventDefault();\n\n    // Save the timestamp for this click to calculate click duration\n    this._pointerDownTime = Date.now();\n    this.pointerDown = true;\n\n    // Find out what was clicked on\n    if(this.game) {\n      // Find selectable items that were clicked on\n      this._potentialSelect = this._currentHovers\n        .filter(hoverable => this.game.selectables.includes(hoverable))\n        .pop();\n      // If the user might have clicked on something, disable panning briefly.\n      if(this._potentialSelect) {\n        this.enablePan = false;\n        setTimeout(() => this.enablePan = true, 100)\n      }\n    }\n  }\n\n  onPointerUp(event) {\n    event.preventDefault();\n\n    // If we're not dragging...\n    if(!this.dragging) {\n      // If we already have something selected...\n      if(this.selection) {\n\n        // If we can place the current selection, do so.\n        if(this.canPlace(this.selection)) {\n          console.log('placing current selection')\n          this.place(this.selection, this.placementTarget)\n          this.deselect();\n        }\n        // If there's something new we could select, then do so.\n        else if(this._potentialSelect) {\n          console.log('selecting new item')\n          // Clear old selection and select new.\n          this.deselect();\n          this.select();\n        }\n        // If we're not hovering over our board, put the ship back.\n        else if (!this.myBoardHovers.length > 0) {\n          console.log('putting down current item')\n          this.sendMoveShipMove(this.selection.id, null, 0);\n          this.deselect()\n        }\n      } else {\n        if(this._potentialSelect) {\n          this.select();\n        }\n      }\n    }\n\n    this.pointerDown = false;\n  }\n\n  onWheel(event) {\n    event.preventDefault();\n\n    // If we have anything picked up, rotate it.\n    if (this.selection) {\n      // Save the selection as \"obj\" for ease of use later\n      const obj = this.selection;\n\n      // Determine direction of rotation\n      const angleDelta = event.deltaY > 0 ? 60 : -60;\n\n      // Determine position and angle to send to the engine\n      const position = obj.atNull ? [obj.nullX, obj.nullY] : obj.enginePosition\n      let angle = obj.angle + angleDelta;\n      if(angle === 360) {\n        angle = 0;\n      } else if(angle === -60) {\n        angle = 300;\n      }\n      this.sendMoveShipMove(obj.id, position, angle)\n    }\n  }\n\n  canPlace(selectable) {\n    // Find the ship in the engine\n    const ship = this.engineBoard.ships[selectable.id]\n\n    // Find potential targets to place\n    this._placementTargets = this._currentHovers.filter(hoverable => selectable.canMoveTo(hoverable))\n\n    // Do validation from the engine board\n    return this._placementTargets.length > 0 &&\n           ship.position !== null &&\n           this.engineBoard.validShipLocation(ship)\n  }\n\n  // Returns true if there are any current hovers or any previous hovers.\n  detectHovers() {\n    // Assume no current hover.\n    this._currentHovers = [];\n\n    // If we have a game and hovering is enabled, find hoverables.\n    if(this.game && !this.dragging) {\n      this._currentHovers = this.game.hoverables\n        .map(h => h.currentHover(this._raycaster)) // Get hovered objects\n        .filter(h => !!h) // Filter out falsy values like undefined or false\n      this.prevMainHover = this.mainHover;\n      this.mainHover = this.myBoardHovers[0];\n    }\n\n    // If we have a selection, find the tiles it's hovering over.\n    if(this.selection && this.canPlace(this.selection)) {\n      this.engineShip.segments.forEach((segment, index) => {\n        if(index !== 0) {\n          const [y, x] = segment.position;\n          const tile = this.gameBoard.tiles[this.gameBoard.tilesByPosition[x][y]];\n          this._currentHovers.push(tile)\n        }\n      })\n    }\n\n    const hovering = this._currentHovers.length > 0;\n    const prevHovering = this._prevHovers.length > 0\n    if (!hovering && prevHovering) {\n      this.setViewerData(prev => {\n        return ({ ...prev, currentHover:null })\n      });\n    }\n\n    // If we have any current hovers or previous hovers, return true so they get handled.\n    return hovering || prevHovering;\n  }\n\n  handleHovers() {\n    // If we were already hovering over any items...\n    // Find new hovers and abandoned hovers.\n    const newHovers = this._currentHovers.filter(currentHoverable => !this._prevHovers.includes(currentHoverable));\n    const abandonedHovers = this._prevHovers.filter(prevHoverable => !this._currentHovers.includes(prevHoverable));\n\n    // If we have a new main hover that wasn't already in the new hover list...\n    if(this.newMainHover && !newHovers.includes(this.mainHover)) {\n      //...add the main hover to the list.\n      newHovers.unshift(this.mainHover)\n    }\n    //If any of the hovers are selected, we don't do hover behavior for that entity.\n    newHovers.forEach(this.handleNewHover);\n    abandonedHovers.forEach(this.handleAbandonedHover);\n\n    const currentHover = this._currentHovers.map(hoverable => hoverable.hoverData)[0]\n\n    if(newHovers.length > 0) {\n      this.setViewerData(prev => ({ ...prev, currentHover, newHovers }));\n    }\n    this._prevHovers = this._currentHovers;\n\n    return true;\n  }\n\n  handleNewHover(hoverable) {\n    // If it's not selected, do its onHover action.\n    !hoverable.selected && hoverable.onHover();\n\n    const selection = this.selection;\n\n    // If there's a selected ship that can move to this hoverable,\n    // move it and update the tiles its segments are hovering over!\n    if(hoverable === this.mainHover &&\n       selection &&\n       selection.canMoveTo(hoverable)) {\n      const playerId = selection.owner.playerId;\n      const shipId = selection.id;\n      const position = hoverable.boardPosition;\n      const angle = selection.angle;\n      this.sendMoveShipMove(shipId, position, angle)\n    }\n  }\n\n  handleAbandonedHover(hoverable) {\n    !hoverable.selected && hoverable.onHoverExit()\n  }\n\n  place(selection) {\n    selection.onPlace();\n    this.sendPlaceShipMove(selection.id)\n  }\n\n  unplace(selection) {\n\n  }\n\n  sendMoveShipMove(shipID, position, angle) {\n    this.setMoveData({\n      moveType: MOVES.MOVE_SHIP.NAME,\n      targetPlayerID: this.playerID,\n      playerID: this.playerID,\n      shipID,\n      position,\n      angle\n    })\n  }\n\n  sendPlaceShipMove(shipID) {\n    this.setMoveData({\n      moveType: MOVES.PLACE_SHIP.NAME,\n      targetPlayerID: this.playerID,\n      playerID: this.playerID,\n      shipID\n    })\n  }\n\n  sendUnplaceShipMove(shipID) {\n    this.setMoveData({\n      moveType: MOVES.UNPLACE_SHIP.NAME,\n      targetPlayerID: this.playerID,\n      playerID: this.playerID,\n      shipID\n    })\n  }\n}\n\nexport { BattleshipControls };","import * as THREE from 'three';\nimport { BattleshipControls } from './BattleshipControls'\nimport Game from './Game';\n\nclass GameViewer {\n  constructor(window, canvasRef, setViewerData, messageDataRef, setMoveData, engine) {\n    this._canvasRef = canvasRef;\n    this._setViewerData = setViewerData;\n    this._messageDataRef = messageDataRef;\n\n    this._scene = new THREE.Scene();\n    this._renderer = new THREE.WebGLRenderer({ canvas: this._canvasRef.current });\n    this._camera = this.setupCamera();\n    this._controls = this.setupControls(setMoveData, engine);\n\n\n    this._renderer.setSize(window.innerWidth, window.innerHeight);\n    this._lights = this.setupLights();\n    this._axes = this.makeAxes();\n\n\n\n\n    // Add initial stuff to scene\n    this.addArr(this._lights);\n    this.add(this._axes);\n\n    // Binding functions that get called in odd scopes\n    this.animate = this.animate.bind(this); // Recursive, so scope changes if unbound\n  }\n\n  get controls() {\n    return this._controls;\n  }\n\n  get update() {\n    return this._messageDataRef.current.update;\n  }\n\n  get game() {\n    return this._currentGame;\n  }\n\n  set update(flag) {\n    this._messageDataRef.current.update = false;\n  }\n\n  add(object) {\n    this._scene.add(object);\n  }\n\n  addArr(objects) {\n    for (let object of objects) {\n      this.add(object)\n    }\n  }\n\n  setupCamera() {\n    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    camera.up = new THREE.Vector3(0, 0, 1)\n    camera.position.z = 20;\n    camera.position.y = 0;\n    camera.position.x = 0;\n    camera.lookAt(0, 0, 0)\n\n    return camera;\n  }\n\n  setupControls(setMoveData) {\n    const controls = new BattleshipControls(this._camera, this._canvasRef.current, this._setViewerData, setMoveData)\n\n    return controls\n  }\n\n\n\n  initGame(gameStateRef, ownerID, engine) {\n    const game = new Game(gameStateRef, ownerID, engine);\n    this._currentGame = game;\n    this.controls.initGame(game, ownerID, engine)\n    this.addGameToScene(game, ownerID)\n  }\n\n  addGameToScene(game, playerId) {\n    // Add filler tiles\n    this.add(game.fillerTiles)\n\n    // For every player:\n    Object.values(game.players).forEach(player => {\n      // Add the tilemesh for the board to the scene\n      this.add(player.board.tileMesh)\n\n      // If the player we're looking at matches the player viewing the board,\n      // add their ship meshes to the scene\n      player.id === playerId && this.addArr(player.board.shipMeshes)\n    });\n  }\n\n  setupLights() {\n    // Add some lights!\n    const light = new THREE.DirectionalLight(0xffffff, 1)\n    const ambientLight = new THREE.AmbientLight(0xffffff, .5)\n\n    // Move the light out to a better position\n    light.position.x = 5;\n    light.position.y = 5;\n    light.position.z = 10;\n\n    this.add(light);\n    this.add(ambientLight);\n    return [light, ambientLight];\n  }\n\n  makeAxes() {\n    //Add colored XYZ axes for dev purposes.\n    return new THREE.AxesHelper(5);\n  }\n\n  animate() {\n    const timestamp = Date.now();\n    requestAnimationFrame(this.animate);\n    this.controls.handleAnimationLoop();\n\n    // If the board needs to be updated, update the board.\n    //TODO: FILL IN\n    //\n    if(this.update) {\n      this._currentGame.update()\n      this.update = false;\n    }\n\n    this._renderer.render(this._scene, this._camera);\n    const fps = (1000 / (Date.now() - timestamp)).toFixed(0);\n    //this._setViewerData(prev => ({...prev, fps}))\n  }\n\n  // Create a simple green cube for dev/test purposes.\n  makeTestCube() {\n    const box = new THREE.BoxGeometry(1, 1, 1);\n    const m = new THREE.MeshBasicMaterial({ color: 0x00ff00 })\n    const cube = new THREE.Mesh(box, m);\n    cube.position.x = 5\n    cube.position.y = 5\n    cube.position.z = 5\n    return cube;\n  }\n}\n\nexport default GameViewer;","import { useEffect, useRef, useState } from 'react'\nimport * as THREE from 'three';\n\nimport GameViewer from '../classes/GameViewer'\n\nexport default function use3DBoard(canvasRef, gameStateRef, engine, playerId) {\n\n  const [viewerData, setViewerData] = useState({\n    pointer: {\n      normalizedPosition: [-1, -1],\n      rawPosition: [0, 0]\n    },\n    camera: {\n      position: [0, 0, 0],\n      rotation: [0, 0, 0, 0]\n    },\n    currentHover: {\n      instanceId: 'none', // ID to find this in the 'tiles' mesh\n      playerId: null, // ID of the owning player\n      worldPosition: null, // Position on the overall visible world\n      boardPosition: null, // Position on the owning player's board\n      hoverable: null\n    },\n    currentSelect: {\n      objectId: 'none',\n      playerId: null,\n      ownerID: null,\n    },\n    selectStack: []\n  });\n  const [moveData, setMoveData] = useState(null)\n  const messageDataRef = useRef({ update: false, timestamp: Date.now() });\n  //console.log('refreshing?')\n\n  useEffect(() => {\n    // === THREE.JS CODE START ===\n\n\n    const viewer = new GameViewer(window, canvasRef, setViewerData, messageDataRef, setMoveData, engine)\n    viewer.initGame(gameStateRef, playerId, engine)\n\n    viewer.animate();\n    // === THREE.JS CODE END ===\n  }, [])\n\n  return [viewerData, messageDataRef, moveData]\n}\n\nconst updateBoard = (gameState) => {\n  console.log('updated')\n  console.log(gameState.players.p1.board.ships)\n  // Update ship positions\n\n  return true;\n}","import { useState, useEffect, useRef } from 'react';\n\nimport '../styles/GameWindow.css'\n\n// Hooks\nimport useGameEngine from '../hooks/useGameEngine'\nimport use3DBoard from '../hooks/use3DBoard'\n\n\n\n// Component\nexport default function GameWindow() {\n  // DEV - REMOVE LATER\n  //console.log('rendering gamewindow')\n  const playerId = 'p2';\n  /************ END DEV DATA*/\n\n  // This ref will hold the DOM <canvas> element where we render the game.\n  const renderCanvas = useRef(null);\n\n\n  const [engine, moves, gameStateRef, makeMove] = useGameEngine();\n  const [viewerData, messageDataRef, moveData] = use3DBoard(renderCanvas, gameStateRef, engine, playerId);\n  const [status, setStatus] = useState('Waiting');\n  const [details, setDetails] = useState();\n\n  const moveAndUpdate = (move) => {\n    setStatus('Move sent. Waiting for engine...');\n    makeMove(move)\n      .then(results => {\n        console.log(results)\n        setStatus({\n          msg: `Move handled. Results: ${results.valid && 'Valid'}. Updating board...`,\n          results\n        })\n      })\n      .then(() => messageDataRef.current.update = true)\n      .catch(err => console.log(\"yo\"))\n  }\n\n  // When moveData changes, send a move to the engine.\n  // All moves should be sent in this way.\n  useEffect(() => {\n    moveData && moveAndUpdate(moveData) && console.log('sending a move');\n  }, [moveData])\n\n  const handleClick = () => {\n    console.log('handling click')\n    const p1Move = {\n      moveType: moves.MOVE_SHIP.NAME,\n      playerID: 'p2',\n      targetPlayerID: 'p2',\n      shipID: 'ship0',\n      position: [0, 0],\n      angle: 180\n    }\n    moveAndUpdate(p1Move)\n\n  }\n\n  const markPlayerReady = () => {\n    if(engine.players[playerId].board.allShipsPlaced) {\n\n    }\n  }\n\n  const shipList = [];\n  gameStateRef.current.players && Object.values(gameStateRef.current.players).forEach(player => {\n    const playerShips = [];\n    Object.values(player.board.ships).forEach(ship => {\n      playerShips.push(<li key={ship.id}>{ship.id}: {ship.segments[1].position}</li>)\n    })\n    shipList.push(\n      <ul key={player.id}>\n        <li>{player.id}: {player.name}</li>\n        <ul>{playerShips}</ul>\n      </ul>\n    )\n  })\n\n  // Create the updated game engine details when they change\n\n  useEffect(() => {\n    const makeDetails = (obj, recursive = false) => {\n      let list = []\n      for(const key in obj) {\n        if(obj[key] instanceof Object || Array.isArray(obj[key])) {\n          list.push(\n            <details>\n              <summary>{key}</summary>\n              {recursive ? makeDetails(obj[key], recursive) : `${obj[key]}`}\n            </details>\n          )\n        }\n        else {\n          list.unshift(<li>{key}: {obj[key]}</li>)\n        }\n      }\n  \n      return (<ul>{list}</ul>)\n    }\n\n    setDetails(makeDetails(gameStateRef.current, true));\n  }, [gameStateRef.current])\n\n\n  const makeString = (arr) => {\n    if(!Array.isArray(arr)) {\n      arr = Object.values(arr)\n    }\n    return arr.map(pos => Number.parseFloat(pos).toFixed(2)).join(', ');\n  }\n\n  const mouseData = viewerData.pointer.normalizedPosition;\n  const cameraPos = viewerData.camera.position;\n  const cameraRot = viewerData.camera.rotation;\n\n  const mouseDataText = makeString(mouseData);\n  const cameraPosText = makeString(cameraPos);\n  const cameraRotText = makeString(cameraRot);\n\n  let currentHoverInfo = [];\n  for (let key in viewerData.currentHover) {\n    currentHoverInfo.push(<li key={key}>{key}: {JSON.stringify(viewerData.currentHover[key])}</li>)\n  }\n\n  // TODO: Set up the debugging info so it only recalculates\n  // when a move is reported.\n  return (\n    <div className=\"game-window\">\n      <div id=\"status\">Status: {status.msg}</div>\n      <div id=\"info\">\n        <h2>Debug panel</h2>\n        <p>Board update: {` ${messageDataRef.current.update}, ${messageDataRef.current.timestamp}`}</p>\n        <ul>\n          <li>Mouse: {mouseDataText}</li>\n          <li>Camera pos: {cameraPosText}</li>\n          <li>Camera rot: {cameraRotText}</li>\n        </ul>\n        <details>\n          <summary>Current hover info</summary>\n          <ul>\n            {currentHoverInfo}\n          </ul>\n        </details>\n        <button \n          onClick={() => handleClick()}\n          disabled={true}\n          >\n          Start the game\n        </button>\n        <details>\n          <summary>Game engine state</summary>\n          {details}\n        </details>\n        <details>\n          <summary>Last move results:</summary>\n          {/* {makeDetails(status.results, true)} */}\n        </details>\n        <details>\n          <summary>Controls info</summary>\n          {/* {makeDetails(viewerData.controls, false)} */}\n        </details>\n      </div>\n{/*       <div id=\"fps\">\n        <span>FPS:{viewerData.fps}</span>\n      </div> */}\n      {/* Assign the renderCanvas ref to this canvas element! */}\n      <canvas ref={renderCanvas} />\n    </div>\n  )\n}","export const SOCKET_DATA = {\n  SERVER: 'http://127.0.0.1:8080'\n};","// Modules\nimport { useState, useEffect } from 'react';\nimport socketClient from 'socket.io-client';\n\n// Components\nimport GameWindow from './GameWindow';\n\n// Constants\nimport { SOCKET_DATA } from '../constants/socket'\n\nimport '../styles/App.css';\n\nfunction App() {\n  const [state, setState] = useState({\n    socketConnected: false,\n  })\n\n\n  useEffect(() => {\n    const socket = socketClient(SOCKET_DATA.SERVER)\n\n    socket.on('connection', () => {\n      setState(prev => ({\n        ...prev,\n        socketConnected: true,\n        socket\n        }\n      ))\n    });\n\n    return function cleanup() {\n      socket.disconnect();\n    }\n  }, [])\n\n  return (\n    <div className=\"App\">\n      <header>\n        <p>\n          Socket server: { SOCKET_DATA.SERVER } |&nbsp;\n          { !state.socketConnected && 'Connecting to server...' }\n          { state.socketConnected && 'Connection established!' }\n        </p>\n\n      </header>\n      <GameWindow />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","/**********************************\n * CONSTANTS FOR BOARD DIMENSIONS\n */\nconst ROWS_TOP = 4;\nconst ROWS_BOTTOM = 4;\nconst COLUMNS_LEFT = 4;\nconst COLUMNS_RIGHT = 4;\nconst COLUMNS_BETWEEN = 2;\n\nconst SHIP_NULL_START = {\n  x: 0,\n  y: -1,\n  angle: 60\n}\n\nconst BOARD_DIMENSIONS = {\n  ROWS_TOP,\n  ROWS_BOTTOM,\n  COLUMNS_LEFT,\n  COLUMNS_RIGHT,\n  COLUMNS_BETWEEN,\n  SHIP_NULL_START\n}\n\n/**********************************/\n\n/**********************************\n * CONSTANTS FOR HEX TILE GEOMETRY\n */\n\n// Distance from tile center to a given vertex\nconst TILE_RADIUS = 1.0;\n\n// Distance from tile center to center of a given side\n// calculation: R * sin(60 deg. or 2pi/6 rad.)\nconst TILE_HEIGHT = TILE_RADIUS * Math.sin(Math.PI / 3);\n\n// Length of a single tile side\n// Equal to HEX_RADIUS since this is a regular hexagon.\n// CURRENTLY UNUSED.\nconst TILE_SIDE = TILE_RADIUS;\n\n// How beefy is that tile\nconst TILE_THICKNESS = 0.25;\n\n// The z-position of the center of a tile to get it to lay \"flat\" on the XY plane\n// (i.e. the back of the tile is at z = 0)\nconst TILE_BASE = TILE_THICKNESS / 2;\n\n// Bundled object for export\nconst TILE_GEOMETRY = {\n  TILE_RADIUS,\n  TILE_HEIGHT,\n  TILE_THICKNESS,\n  TILE_SIDE,\n  TILE_BASE\n}\n/**********************************/\n\n/**********************************\n * CONSTANTS FOR MATERIALS\n */\n\nconst TILE_MATERIAL = {\n  color: 0xffffff, // If the base color is white, we can apply any other color easily!\n  roughness: 0.6,\n  metalness: 0.5\n}\n\n// Bundled object for export\nconst MATERIALS = {\n  TILE_MATERIAL\n}\n/**********************************/\n\n/**********************************\n * HEX VALUE CONSTANTS FOR COLORS\n */\n\n// GENERAL\nconst BAD_HOVER_COLOR = 0xff0000;\n\n// TILES\nconst PLAYER_BOARD_TILE_BASE_COLOR = 0x0066ff;\nconst PLAYER_BOARD_TILE_HOVER_COLOR = 0x4477ff;\nconst TILE_NONINTERACTIVE_COLOR = 0x0044dd;\n\n// LIGHTS\nconst LIGHT_BASE_COLOR = 0xffffff;\n\n// Bundled object for export\nconst COLORS = {\n  PLAYER_BOARD_TILE_BASE_COLOR,\n  PLAYER_BOARD_TILE_HOVER_COLOR,\n  BAD_HOVER_COLOR,\n  TILE_NONINTERACTIVE_COLOR,\n  LIGHT_BASE_COLOR\n}\n/**********************************/\n\nmodule.exports = {\n  BOARD_DIMENSIONS,\n  TILE_GEOMETRY,\n  MATERIALS,\n  COLORS\n}"],"sourceRoot":""}